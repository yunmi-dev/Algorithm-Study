# [나머지가 1이 되는 수 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/87389)

## 📌 문제 설명
자연수 `n`이 매개변수로 주어집니다. `n`을 `x`로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 `x`를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.


### 제한사항

- 3 ≤ `n ≤ 1,000,000

### 입출력 예
| n  | result |
|----|--------|
| 10 | 3      |
| 12 | 11     |

### 입출력 예 설명
입출력 예 #1
- 10을 3으로 나눈 나머지가 1이고, 3보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 3을 return 해야 합니다.

입출력 예 #2
- 12를 11로 나눈 나머지가 1이고, 11보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 11을 return 해야 합니다.



## 🧰 풀이

### 풀이 과정
1. n보다 작은 자연수들을 순회하면서 나머지가 1이 되는 가장 작은 수를 찾는 방식으로 구현


2. 결과값을 저장할 변수 result를 n으로 초기화

    - 최악의 경우 n-1이 답이 될 수 있음


3. 최종적으로 조건에 부합하는 가장 작은 수 반환


### 시간복잡도
      - O(n): n은 입력받은 자연수
         - 최악의 경우 2부터 n-1까지 모든 수를 확인해야 함
         - 각 반복에서 수행되는 연산(나머지 연산, 비교)은 O(1)
         - 따라서 전체 시간복잡도는 O(n)

### 공간복잡도
      - O(1): 입력 크기와 관계없이 고정된 추가 메모리만 사용
         - result 변수: O(1)
         - 반복문 카운터 i: O(1)
         - 추가적인 자료구조를 사용하지 않음

## ✨ 새롭게 배운 점
1. 수학적 최적화 가능성
    - 나머지가 1이 되는 수는 n-1의 약수일 수 있다는 수학적 특성
    - 이를 활용하면 더 효율적인 알고리즘 구현 가능


2. 초기값 설정의 중요성
    - result를 n으로 초기화함으로써 별도의 예외처리 없이 알고리즘 구현
    - 최악의 경우(답이 n-1인 경우)도 자연스럽게 처리


## 💡 개선할 수 있는 점
1. 수학적 최적화

```java
public int solution(int n) {
    for (int i = 2; i <= Math.sqrt(n); i++) {
        if ((n - 1) % i == 0) {
            return i;
        }
    }
    return n - 1;
}
```
   - n-1의 약수를 찾는 방식으로 최적화
   - 시간복잡도를 O(√n)으로 개선 가능


2. early return 적용

```java
public int solution(int n) {
    for (int i = 2; i < n; i++) {
        if (n % i == 1) {
            return i;
        }
    }
    return n - 1;
}
```
   - result 변수 없이 바로 반환할 수 있었음


3. 입력값 검증 추가
```java
public int solution(int n) {
    if (n < 3) {
        throw new IllegalArgumentException("n must be greater than or equal to 3");
    }

    for (int i = 2; i < n; i++) {
        if (n % i == 1) {
            return i;
        }
    }
    return n - 1;
}
```
   - 문제 조건(3 ≤ n ≤ 1,000,000)에 맞는 입력값 검증
