# [나머지](https://www.acmicpc.net/problem/3052)

## 📌 문제
두 자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다.

수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.

### 입력
첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.

### 출력
첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.

### 예제 입력 1

     1
     2
     3
     4
     5
     6
     7
     8
     9
     10

### 예제 출력 1

     10



### 예제 입력 2

     42
     84
     252
     420
     840
     126
     42
     84
     420
     126

### 예제 출력 2

     1



### 예제 입력 3

     39
     40
     41
     42
     43
     44
     82
     83
     84
     85

### 예제 출력 3

     6



### 🧰 풀이 과정

1. HashSet 초기화
   - 서로 다른 나머지 값을 저장할 HashSet 생성
   - HashSet은 중복을 자동으로 제거해주는 자료구조이므로 선택


2. 나머지 계산 및 저장
   - 10개의 수를 입력받아 각각 42로 나눈 나머지 계산
   - 계산된 나머지를 HashSet에 추가
   - 중복된 나머지는 자동으로 제거됨


3. HashSet의 크기를 출력 (즉, 서로 다른 나머지 개수)



### 시간복잡도와 공간복잡도

      
      시간복잡도: O(1)
         - 입력 개수가 10으로 고정
         - HashSet의 add 연산은 O(1)
         - 전체 반복 횟수가 10으로 고정되어 있으므로 O(1)
      
      공간복잡도: O(1)
         - HashSet 크기가 최대 42로 제한됨 (나머지는 0~41)
         - 입력값 저장에 필요한 공간이 상수
         - 추가 변수도 상수 크기


### ✨ 새롭게 배운 점
1. HashSet 활용
   - 중복 제거가 필요할 때 유용한 자료구조
   - add() 메소드로 간단히 요소 추가
   - size() 메소드로 고유한 요소 개수 확인


### 💡 성능 개선 포인트
1. boolean 배열 활용 (알고 넘어가는 정도)

```java
// 현재: HashSet 사용
HashSet<Integer> set = new HashSet<>();
for (int i = 0; i < 10; i++) {
    set.add(Integer.parseInt(br.readLine()) % 42);
}

// 개선: boolean 배열 사용
boolean[] remains = new boolean[42];
int count = 0;
for (int i = 0; i < 10; i++) {
    int remainder = Integer.parseInt(br.readLine()) % 42;
    if (!remains[remainder]) {
        remains[remainder] = true;
        count++;
    }
}
```

- 실제로는 현재 구현이 더 간단하고 가독성이 좋음
- 그래봤자 입력 크기가 작아서 성능 차이는 미미함