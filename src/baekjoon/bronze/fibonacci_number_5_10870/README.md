# [피보나치 수 5](https://www.acmicpc.net/problem/10870)

## 📌 문제
피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.

이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.

n=17일때 까지 피보나치 수를 써보면 다음과 같다.

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597

n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.

### 출력
첫째 줄에 n번째 피보나치 수를 출력한다.

### 예제 입력 1

     10

### 예제 출력 1

     55


### 🧰 풀이 과정

반복문을 사용한 상향식(Bottom-up) 접근 방식으로 해결

1. 배열 초기화
    - fibo[0] = 0
    - fibo[1] = 1 로 기본 케이스 설정


2. 반복문으로 피보나치 수 계산


### 시간복잡도와 공간복잡도

      
      시간복잡도: O(N)
         - 입력값 n만큼 한 번의 반복문을 수행
         - 각 반복에서 덧셈 연산은 O(1)
         - 따라서 전체 시간복잡도는 O(N)
      
      공간복잡도: O(1)
         - 크기가 21인 고정 배열 사용 (n은 20 이하니까)
         - 입력 크기와 관계없이 항상 같은 크기의 배열 사용
         - 따라서 공간복잡도는 O(1)


### ✨ 새롭게 배운 점
1. BufferedWriter 사용시 int 타입을 직접 쓸 수 없고 String으로 변환 필요
    - String.valueOf() 메소드를 활용하여 형변환

### 💡 성능 개선 포인트
1. 메모리 사용 최적화

```java
// 현재: 고정 크기 배열 사용
int[] fibo = new int[21];

// 개선: 필요한 크기만큼만 할당
int[] fibo = new int[n + 1];
```

2. 변수 두 개만 사용하여 공간복잡도 개선 가능

```java
int a = 0, b = 1;
for (int i = 2; i <= n; i++) {
    int temp = a + b;
    a = b;
    b = temp;
}
return n == 0 ? a : b;
```
- 이 방식을 사용하면 공간복잡도를 O(1)로 유지하면서도 배열 할당 없이 구현 가능