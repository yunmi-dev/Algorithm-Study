# [알파벳 찾기](https://www.acmicpc.net/problem/10809)

## 📌 문제
알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.

### 입력
첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.

### 출력
각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, ... z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.

만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.

### 예제 입력 1

     baekjoon

### 예제 출력 1

     1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1



### 🧰 풀이 과정

1. 입력값 처리
   - BufferedReader로 문자열 S 입력 받기


2. 위치 찾기
   - 'a'부터 'z'까지 반복문으로 순회
   - indexOf() 메소드로 각 알파벳의 첫 등장 위치 찾기 (없으면 -1 반환하는 것도 적격)
   - StringBuilder에 결과값과 공백 추가


3. 결과 출력
   - StringBuilder에 모은 모든 위치 정보 출력



### 시간복잡도와 공간복잡도

      
      시간복잡도: O(26 × N) = O(N)
         - 알파벳 26개에 대해 반복
         - 각 반복마다 indexOf()로 문자열 전체 검색 (길이 N)
         - StringBuilder 연산은 O(1)
      
      공간복잡도: O(1)
         - 입력 문자열 저장: O(N)
         - 결과 저장용 StringBuilder: O(1)
         - 추가 자료구조 없음
         - 입력 크기와 무관한 고정 공간 사용


### ✨ 새롭게 배운 점
1. 문자열 처리 최적화 
   - String 더하기보다 StringBuilder가 효율적


2. Java 문자 처리
   - char 타입을 for문에서 증가 연산자와 함께 사용
   - 'a'부터 'z'까지 직접 비교 가능
   - indexOf()가 못 찾으면 -1 반환


3. String 메소드
   - indexOf()로 첫 등장 위치 쉽게 찾기
   - char 타입과 String 타입 모두 검색 가능함


### 💡 성능 개선 포인트
1. 한 번의 순회로 모든 알파벳 위치 찾기

```java
// 현재: indexOf() 여러 번 호출
for (char i = 'a'; i <= 'z'; i++) {
    sb.append(S.indexOf(i)).append(' ');
}

// 개선: 한 번의 순회로 해결
int[] pos = new int[26];
Arrays.fill(pos, -1);

for(int i = 0; i < S.length(); i++) {
    int idx = S.charAt(i) - 'a';
    if(pos[idx] == -1) pos[idx] = i;
}
```

- 현재 구현은 O(N) 시간복잡도지만 문자열을 여러 번 훑음
- 개선된 버전은 한 번의 순회로 같은 O(N) 시간복잡도 달성