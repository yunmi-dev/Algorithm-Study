# [두 수의 합](https://www.acmicpc.net/problem/3273)

## 📌 문제
n개의 서로 다른 양의 정수 a1, a2, ..., an으로 이루어진 수열이 있다. ai의 값은 1보다 크거나 같고, 1000000보다 작거나 같은 자연수이다. 자연수 x가 주어졌을 때, ai + aj = x (1 ≤ i < j ≤ n)을 만족하는 (ai, aj)쌍의 수를 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 수열의 크기 n이 주어진다. 다음 줄에는 수열에 포함되는 수가 주어진다. 셋째 줄에는 x가 주어진다. (1 ≤ n ≤ 100000, 1 ≤ x ≤ 2000000)

### 출력
문제의 조건을 만족하는 쌍의 개수를 출력한다.

### 예제 입력 1

    9 
    5 12 7 10 9 1 2 3 11
    13

### 예제 출력 1

    3


### 🧰 풀이 과정

1차 시도 (시간 초과)
1. 이중 for문을 사용해 모든 쌍을 직접 확인
2. 두 수의 합이 x인 경우 카운팅
```java
for(int i = 0; i < n-1; i++) {
    for(int j = i+1; j < n; j++) {
        if(arr[i] + arr[j] == x) count++;
    }
}
```

2차 시도 (성공)
1. HashSet을 사용하여 모든 수를 저장 (단일 반복문 사용을 위해 HashSet 선택)
2. 각 수에 대해 x에서 뺀 값(complement)이 Set에 존재하는지 확인 
3. 자기 자신과의 쌍을 제외 (x - num != num)
4. 각 쌍이 두 번씩 카운트되므로 최종 결과를 2로 나눔

### 시간복잡도와 공간복잡도

* 1차 시도


    시간복잡도: O(n²)

    공간복잡도: O(n)

* 2차 시도


    시간복잡도: O(n)

    공간복잡도: O(n)



### ✨ 새롭게 배운 점
1. HashSet를 사용할 수 있게 됐다.
    - O(1) 시간만에 원소 존재 여부 확인 가능!
    - 중복을 허용하지 않는 특성 활용


2. 시간 복잡도의 중요성 실감
    - n ≤ 100,000인 경우 O(n²)은 시간 초과
    - 적절한 자료구조 선택으로 시간복잡도 개선 필요 
   
3. BufferedReader 사용
    - Scanner 대신 BufferedReader 사용으로 입력 처리 시간 단축
