# [에디터](https://www.acmicpc.net/problem/1406)

## 📌 문제
한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.

이 편집기에는 '커서'라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.

이 편집기가 지원하는 명령어는 다음과 같다.

L	커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨)
D	커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨)
B	커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨)
삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임
P $	$라는 문자를 커서 왼쪽에 추가함
초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.

### 입력
첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.

### 출력
첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.

### 예제 입력 1

    abcd
    3
    P x
    L
    P y

### 예제 출력 1

    abcdyx


### 예제 입력 2

    abc
    9
    L
    L
    L
    L
    L
    P x
    L
    B
    P y

### 예제 출력 2

    yxabc

### 예제 입력 3

    dmih
    11
    B
    B
    P x
    L
    B
    B
    B
    P y
    D
    D
    P z


### 예제 출력 3

    yxz




### 🧰 풀이 과정

1차 시도 - Stack (시간 초과)
1. 하나의 Stack을 사용하여 문자열 처리
2. 커서 위치를 인덱스로 관리하며 add(index), remove(index) 사용 -> 사용할 때마다 O(n)

```java
Stack<Character> strStack = new Stack<>();
// add(index), remove(index) 사용으로 인한 O(n) 연산 발생
```

2차 시도 - Stack (성공)
1. 두 개의 Stack을 사용하여 커서 위치를 기준으로 문자열을 분리 
2. 왼쪽 스택과 오른쪽 스택으로 나누어 관리 
3. push/pop 연산만을 사용하여 O(1) 시간에 모든 연산 처리 
4. StringBuilder를 사용하여 출력 최적화 (하기 전엔 시간 초과 났음)


3차 시도 - LinkedList (성공)
1. LinkedList와 ListIterator를 사용하여 구현 
2. ListIterator로 커서 위치를 관리하며 O(1) 시간에 모든 연산 처리 
3. 커서의 위치를 요소 사이의 "틈"으로 관리하여 직관적인 구현 가능


### 시간복잡도와 공간복잡도

* 1차 시도


    시간복잡도: O(n²)
      - 중간 삽입/삭제 연산이 O(n)
      - M번의 연산 수행으로 총 O(M*N)

    공간복잡도: O(n)
      - 하나의 스택에 n개의 문자 저장

* 2차 시도


    시간복잡도: O(n + m)
      - 모든 연산이 O(1)
      - n: 초기 문자열 길이, m: 명령어 수

    공간복잡도: O(n)
      - 두 개의 스택에 총 n개의 문자 분할 저장

* 3차 시도


    시간복잡도: O(n + m)
      - ListIterator를 사용하여 모든 연산이 O(1)
      - n: 초기 문자열 길이, m: 명령어 수

    공간복잡도: O(n)
      - LinkedList에 n개의 문자 저장
      - 각 노드당 앞뒤 링크 추가 저장

### ✨ 새롭게 배운 점
1. Stack의 효율적인 사용방법
    - push/pop은 O(1), add(index)/remove(index)는 O(n)
    - 실제 스택 용도로 쓸 때는 항상 push/pop 사용해야 함 (주의)
    - Stack에서 좋은 사용: push, pop, peek - 맨 위 요소 접근 O(1)
    - Stack에서 피해야 할 사용: add, remove, get - 중간 요소 접근 O(n)
    - 스택의 경우 시간복잡도에 예민하니 신경써야 함


2. 두 개의 스택을 활용한 커서 구현
    - 커서를 기준으로 왼쪽/오른쪽 스택 분리
    - 각 연산을 O(1)에 처리 가능해짐
  
 
3. StringBuilder 활용 

   - 많은 문자열 연산시 System.out.print 대신 StringBuilder 사용
   - 출력 처리 시간 감소폭 큼


4. LinkedList와 ListIterator 활용

   - ListIterator로 커서 구현 시 직관적이고 효율적
   - "요소 사이의 틈"을 커서로 활용하는 개념 학습
   - 양방향 순회가 가능한 LinkedList를 활용해봄