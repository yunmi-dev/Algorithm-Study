# [동전 0](https://www.acmicpc.net/problem/11047)

## 📌 문제
준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.

동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)

둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

### 출력
첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

### 예제 입력 1

     10 4200
     1
     5
     10
     50
     100
     500
     1000
     5000
     10000
     50000

### 예제 출력 1

     6

### 예제 입력 2

     10 4790
     1
     5
     10
     50
     100
     500
     1000
     5000
     10000
     50000

### 예제 출력 2

     12


### 🧰 풀이 과정

그리디 알고리즘을 활용한 최소 동전 개수 계산 구현
그리디 알고리즘을 선택한 이유:
- 가장 큰 단위의 동전부터 사용하면 최적해 보장
- 문제 조건에서 각 동전이 이전 동전의 배수라는 조건이 있어 그리디 접근 가능
- 대표적인 그리티 예제

이 문제에서 그리디가 성립하는 이유:
- 각 동전의 가치가 그 이전 동전의 가치의 배수라는 조건이 있음
- 이 조건 때문에 큰 동전을 우선 사용하는 것이 항상 최적해가 됨
- 만약 이 조건이 없다면 그리디로 최적해를 보장할 수 없었을 것 


1. 입력 처리 및 초기화
   - BufferedReader로 동전 종류(N)와 목표 금액(K) 입력
   - 동전 가치를 저장할 배열 생성


2. 동전 계산 로직
   - 큰 단위의 동전부터 처리 (역순 순회)
   - while문으로 현재 동전으로 만들 수 있는 만큼 반복 처리
   - 매 반복마다 목표 금액에서 동전 가치를 빼고 카운트 증가


3. 최종적으로 필요한 동전 개수 출력



### 시간복잡도와 공간복잡도

      
      시간복잡도: O(K)
         - 최악의 경우, K원이 주어졌는데 모든 동전이 1원짜리밖에 없다고 가정하면 K번의 연산이 필요함
         - 최선의 경우, 단 한번의 연산이 필요함
         - 따라서 시간복잡도는 O(K)
      
      공간복잡도: O(N)
         - 동전의 가치를 저장하는 배열만 필요
         - 추가적인 자료구조 사용하지 않음



### ✨ 새롭게 배운 점
1. 그리디 알고리즘의 조건
   - 각 동전이 이전 동전의 배수여야 그리디 접근이 최적해 보장
   - 이 조건이 없다면 다이나믹 프로그래밍 필요할 수 있음



### 💡 성능 개선 포인트
1. 입력 처리 최적화
   - StringBuilder 활용하여 출력 버퍼링 가능
   - readLine() 대신 read()를 사용하여 더 빠른 입력 처리 가능


2. 알고리즘 최적화
   - 현재는 while문으로 한 단위씩 처리
   - 나눗셈 연산자를 사용하여 한번에 필요한 동전 개수 계산 가능
   ```java
   count += K / coinType[i];
   K %= coinType[i];
   ```
   

3. 메모리 사용 최적화
   - 동전 배열을 역순으로 입력받으면 역순 순회 필요 없음
   - 필요한 경우 배열 대신 즉시 처리도 가능