# [포도주 시식](https://www.acmicpc.net/problem/2156)

## 📌 문제
효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

### 입력
첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.

### 출력
첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

### 예제 입력 1

     6
     6
     10
     13
     9
     8
     1

### 예제 출력 1

     33


### 🧰 풀이 과정

동적 계획법(DP)을 사용하여 해결

1. 상태 정의
   - dp[i][0]: i번째 잔을 마시지 않았을 때의 최대값
   - dp[i][1]: i번째 잔을 마시고, i-1번째 잔은 마시지 않았을 때의 최대값
   - dp[i][2]: i번째 잔과 i-1번째 잔을 연속으로 마셨을 때의 최대값


2. 초기값 설정
   - dp[1][0] = 0;
   - dp[1][1] = wines[1];
   - dp[2][0] = wines[1];
   - dp[2][1] = wines[2];
   - dp[2][2] = wines[1] + wines[2];


3. 점화식 도출
   - dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1][1], dp[i-1][2]));
   - dp[i][1] = Math.max(dp[i-2][0], Math.max(dp[i-2][1], dp[i-2][2])) + wines[i];
   - dp[i][2] = Math.max(dp[i-3][0], Math.max(dp[i-3][1], dp[i-3][2])) + wines[i-1] + wines[i];

* 처음에 시도했던 잘못된 점화식
   ```java
   dp[i][0] = dp[i-1][2];                  // 현재 잔을 안 마시는 경우: 한칸 전 상태들 중 최댓값
   dp[i][1] = dp[i-1][0] + wines[i];       // 현재 잔을 마시는 경우: 두칸 전 상태들 중 최대값 + 현재 와인잔
   dp[i][2] = dp[i-1][1] + wines[i];       // 현재 잔을 마시고, 이전 잔도 마신 경우: 세칸 전 상태들 중 최대값 + 직전 잔 + 현재 잔
   ```
  * 문제점:
    1) dp[i][0]: "이전 잔까지 연속 2잔을 마셨다면, 이번 잔은 마실 수 없으니 이전 상태를 그대로 가져오자" -> 그러나 이전 잔을 안 마셨다고 해서, 꼭 그 직전 상태(dp[i-1][0])에서만 와야 하는 건 아니다. 두 잔 전의 어떤 상태에서도 올 수 있다.
    2) dp[i][1]: "이전 잔을 안 마신 상태에서 현재 잔을 마시자" -> 그러나 이전 잔을 안 마셨다고 해서, 꼭 그 직전 상태(dp[i-1][0])에서만 와야 하는 건 아니다. 두 잔 전의 어떤 상태에서도 올 수 있다.
    3) dp[i][2]: "이전 잔을 마셨고, 그 이전 잔은 안 마신 상태에서 현재 잔을 마시자" -> 이전 잔을 마시더라도, 그 이전의 상태는 더 다양할 수 있다.


            * DP 문제 접근할 때 "바로 이전 상태"만 고려하려고 해서 발생한 실수인데, 더 이전 상태들도 함께 고려해야 최적해를 찾을 수 있다.


4. 최종 결과: n번째 위치에서의 세 가지 상태 중 최대값 선택



### 시간복잡도와 공간복잡도

      
      시간복잡도: O(N)
         - 각 i에 대해 상수 시간의 연산을 수행
         - i는 3부터 n까지 순회하므로 O(n)
      
      공간복잡도: O(N)
         - (n+1) × 3 크기의 2차원 배열(dp) 사용
         - n+1 크기의 1차원 배열(wines) 사용
         - 따라서 전체 공간복잡도는 O(n)



### ✨ 새롭게 배운 점
1. DP에서 상태 정의 하는법
   - 단순히 "이전에 마신 경우/안 마신 경우"가 아닌, 더 세분화된 상태 정의가 필요
   - 연속 3잔 제한을 효과적으로 처리하기 위한 상태 설계


2. DP 점화식 설계 방법
   - 현재 상태에 영향을 미치는 이전 상태들을 정확히 파악
   - 이전 2-3단계까지의 상태를 고려해야 하는 경우의 처리


3. 점화식 개선의 중요성
   - 처음 작성한 점화식의 한계를 파악하고 개선하는 과정에서 DP의 본질적인 특성을 더 깊이 이해
   - 각 상태에서 고려해야 할 이전 상태들의 범위를 정확히 파악하는 것의 중요성
   - 단순히 직전 상태만이 아닌, 더 이전 상태들도 고려해야 하는 경우가 있다는 것을 학습


4. 문제 제약 조건의 정확한 반영
   - "연속 3잔을 마실 수 없다"는 제약을 점화식에 정확히 반영하기 위해서는
   단순히 이전 상태만이 아닌, 2-3단계 이전의 상태까지 고려해야 함을 깨달음

### 💡 성능 개선 포인트
1. 메모리 사용 최적화

```java
// 현재: n+1 크기의 배열 사용
int[][] dp = new int[n + 1][3];

// 개선: 최근 3개 상태만 필요
int[][] dp = new int[4][3];
```
   - dp[i]의 계산에는 최대 3단계 이전의 상태만 필요
   - 순환 배열을 사용하여 공간복잡도를 O(1)로 개선 가능
