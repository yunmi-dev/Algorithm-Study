# [RGB거리](https://www.acmicpc.net/problem/1149)

## 📌 문제
RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

### 입력
첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

### 출력
첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

### 예제 입력 1

     3
     26 40 83
     49 60 57
     13 89 99

### 예제 출력 1

     96


### 예제 입력 2

     3
     1 100 100
     100 1 100
     100 100 1

### 예제 출력 2

     3


### 예제 입력 3

     3
     1 100 100
     100 100 100
     1 100 100

### 예제 출력 3

     102


### 예제 입력 4

     6
     30 19 5
     64 77 64
     15 19 97
     4 71 57
     90 86 84
     93 32 91

### 예제 출력 4

     208


### 예제 입력 5

     8
     71 39 44
     32 83 55
     51 37 63
     89 29 100
     83 58 11
     65 13 15
     47 25 29
     60 66 19

### 예제 출력 5

     253




### 🧰 풀이 과정

동적 계획법(DP)을 사용하여 해결

1. 상태 정의
   - dp[i][j]: i번째 집을 j색으로 칠했을 때의 최소 비용 (이게 어려웠음)
   - j는 0(R), 1(G), 2(B)를 의미


2. 초기값 설정
   - dp[1][0] = costs[1][0] (첫 집을 빨강으로 칠했을 때의 최소비용)
   - dp[1][1] = costs[1][1] (첫 집을 초록으로 칠했을 때의 최소비용)
   - dp[1][2] = costs[1][2] (첫 집을 파랑으로 칠했을 때의 최소비용)


3. 점화식 도출
   - dp[i][0] = costs[i][0] + Math.min(dp[i-1][1], dp[i-1][2])  // 현재 빨강
   - dp[i][1] = costs[i][1] + Math.min(dp[i-1][0], dp[i-1][2])  // 현재 초록
   - dp[i][2] = costs[i][2] + Math.min(dp[i-1][0], dp[i-1][1])  // 현재 파랑


4. Bottom-up 방식으로 구현
   - 2번 집부터 N번 집까지 순차적으로 계산
   - 각 집마다 세 가지 색상의 최소 비용 계산


5. 최종 결과: N번 집의 세 가지 색상 중 최소값 선택



### 시간복잡도와 공간복잡도

      
      시간복잡도: O(N)
         - N개의 집에 대해 각각 3가지 색상의 계산 수행
         - 각 계산은 O(1)의 시간 복잡도
         - 따라서 전체 시간복잡도는 O(N)
      
      공간복잡도: O(N)
         - (N+1) × 3 크기의 2차원 배열(dp) 사용
         - (N+1) × 3 크기의 2차원 배열(costs) 사용
         - 추가 변수들은 상수 공간
         - 전체 공간복잡도는 O(N)



### ✨ 새롭게 배운 점
1. DP를 활용한 문제 해결 패턴
   - 상태를 명확히 정의해야 함
   - 이전 상태가 다음 상태에 미치는 영향 분석
   - 최적 부분 구조(Optimal Substructure) 활용


2. 2차원 배열을 활용한 DP 구현
   - 여러 상태를 동시에 추적하는 방법
   - 이전 상태들 중 최적값 선택


### 💡 성능 개선 포인트
1. 메모리 사용 최적화

   ```java
   // 현재: 두 개의 N+1 크기 배열 사용
   int[][] costs = new int[N + 1][3];
   int[][] dp = new int[N + 1][3];
   
   // 개선: 이전 상태만 필요하므로 두 행만 사용
   int[][] dp = new int[2][3];
   ```
   - DP를 구할 떄 모든 상태를 저장해놓을 필요 없이, "직전 상태"만 있으면 현재 상태 구할 수 있음
   - 따라서 N+1 개로 배열 잡을 필요가 없었음


2. 불필요한 배열 제거
   - costs 배열 없이 직접 dp 배열에 계산 가능
   - 입력 받은 즉시 DP 계산을 수행하면 메모리 절약 가능