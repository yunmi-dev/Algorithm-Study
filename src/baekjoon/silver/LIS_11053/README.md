# [가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

## 📌 문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

### 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

### 출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

### 예제 입력 1

     6
     10 20 10 30 20 50

### 예제 출력 1

     4


### 🧰 풀이 과정

동적 계획법(DP)을 사용하여 해결

1. 상태 정의
   - dp[i][j]: i번째 집을 j색으로 칠했을 때의 최소 비용 (이게 어려웠음)
   - j는 0(R), 1(G), 2(B)를 의미


2. 초기값 설정
   - dp[1][0] = costs[1][0] (첫 집을 빨강으로 칠했을 때의 최소비용)
   - dp[1][1] = costs[1][1] (첫 집을 초록으로 칠했을 때의 최소비용)
   - dp[1][2] = costs[1][2] (첫 집을 파랑으로 칠했을 때의 최소비용)


3. 점화식 도출
   - dp[i][0] = costs[i][0] + Math.min(dp[i-1][1], dp[i-1][2])  // 현재 빨강
   - dp[i][1] = costs[i][1] + Math.min(dp[i-1][0], dp[i-1][2])  // 현재 초록
   - dp[i][2] = costs[i][2] + Math.min(dp[i-1][0], dp[i-1][1])  // 현재 파랑


4. Bottom-up 방식으로 구현
   - 2번 집부터 N번 집까지 순차적으로 계산
   - 각 집마다 세 가지 색상의 최소 비용 계산


5. 최종 결과: N번 집의 세 가지 색상 중 최소값 선택



### 시간복잡도와 공간복잡도

      
      시간복잡도: O(N)
         - N개의 집에 대해 각각 3가지 색상의 계산 수행
         - 각 계산은 O(1)의 시간 복잡도
         - 따라서 전체 시간복잡도는 O(N)
      
      공간복잡도: O(N)
         - (N+1) × 3 크기의 2차원 배열(dp) 사용
         - (N+1) × 3 크기의 2차원 배열(costs) 사용
         - 추가 변수들은 상수 공간
         - 전체 공간복잡도는 O(N)



### ✨ 새롭게 배운 점
1. DP를 활용한 문제 해결 패턴
   - 상태를 명확히 정의해야 함
   - 이전 상태가 다음 상태에 미치는 영향 분석
   - 최적 부분 구조(Optimal Substructure) 활용


2. 2차원 배열을 활용한 DP 구현
   - 여러 상태를 동시에 추적하는 방법
   - 이전 상태들 중 최적값 선택


### 💡 성능 개선 포인트
1. 메모리 사용 최적화

   ```java
   // 현재: 두 개의 N+1 크기 배열 사용
   int[][] costs = new int[N + 1][3];
   int[][] dp = new int[N + 1][3];
   
   // 개선: 이전 상태만 필요하므로 두 행만 사용
   int[][] dp = new int[2][3];
   ```
   - DP를 구할 떄 모든 상태를 저장해놓을 필요 없이, "직전 상태"만 있으면 현재 상태 구할 수 있음
   - 따라서 N+1 개로 배열 잡을 필요가 없었음


2. 불필요한 배열 제거
   - costs 배열 없이 직접 dp 배열에 계산 가능
   - 입력 받은 즉시 DP 계산을 수행하면 메모리 절약 가능