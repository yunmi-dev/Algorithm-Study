# [1로 만들기](https://www.acmicpc.net/problem/1463)

## 📌 문제
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.


정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

### 입력
첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.

### 출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

### 예제 입력 1

     2


### 예제 출력 1

     1


### 예제 입력 2

     10


### 예제 출력 2

     3


### 힌트
10의 경우에 10 → 9 → 3 → 1 로 3번 만에 만들 수 있다.


## 🧰 풀이 과정

### 1차 시도: 그리디 접근 (실패)

처음에는 그리디 알고리즘으로 접근함
- 매 순간 가장 큰 수로 나누는 것이 최적일 것이라 가정
- 1에서 시작해서 N까지 가능한 조건 내에서 큰 수를 곱하는 걸 우선하는 방식으로 구현

```java
while (x != N) {
    if (3 * x <= N) x *= 3;
    else if (2 * x <= N) x *= 2;
    else x += 1;
    count++;
}
```

* 이 접근이 실패한 이유:
  1. 역방향으로 접근했기 때문에 최적해를 놓침 
  
  2. 예를 들어 N=8의 경우:
     - 그리디 방식: 1→3→6→7→8 (4번) 이라고 예상했지만
     - 실제 최적 경로: 8→4→2→1 (3번)
     - 즉, 큰 수로 나누는 것이 항상 최적이 아님
     
  3. 각 단계에서의 최선의 선택이 전체의 최적해를 보장하지 않는 문제

### 2차 시도: Dynamic Programming(DP)을 사용하여 해결
- Bottom-up 방식으로 1부터 N까지 각 숫자를 1로 만드는 최소 연산 횟수를 계산
- 메모이제이션을 통해 중복 계산을 방지

DP를 떠올린 이유:
- 작은 문제의 해가 큰 문제의 해를 구성함
   - N을 1로 만드는 최소 횟수 = min(N/3, N/2, N-1을 1로 만드는 최소 횟수) + 1


- 중복되는 부분 문제 존재
   - 예: 5→4→2→1과 8→4→2→1에서 모두 4→2→1 과정이 필요


1. 초기화
   - DP 배열 생성: memo[N+1]
   - 기저 사례 정의: memo[1] = 0, memo[2] = 1, memo[3] = 1


2. Bottom-up DP
   - 4부터 N까지 순차적으로 계산
   - 각 숫자 i에 대해:
      * i가 3으로 나누어 떨어질 때: memo[i/3] + 1
      * i가 2로 나누어 떨어질 때: memo[i/2] + 1
      * i-1의 경우: memo[i-1] + 1
   - 위 세 가지 경우 중 최솟값을 memo[i]에 저장


3. 결과 출력
   - memo[N] 출력


### 시간복잡도와 공간복잡도

      
      시간복잡도: O(N)
         - 1부터 N까지 한 번씩만 순회
         - 각 숫자에 대해 3가지 연산의 최솟값을 구하는 것은 O(1)
         - 따라서 전체 시간복잡도는 O(N)
      
      공간복잡도: O(N)
         - N+1 크기의 DP 배열 사용
         - 그 외 변수들은 O(1) 공간 사용



### ✨ 새롭게 배운 점
1. DP 문제 해결 패턴
   - 최적 부분 구조(Optimal Substructure) 파악
   - Bottom-up vs Top-down 접근법 선택
   - 메모이제이션을 통한 성능 최적화


2. 예외 처리의 중요성
   - ArrayIndexOutOfBoundsException 방지를 위한 조건 처리
   - 입력값 범위(N ≥ 1)에 따른 초기값 설정


### 💡 성능 개선 포인트

1. 불필요한 변수 제거
   - case1, case2, case3 변수를 직접 계산식으로 대체 가능

```java
memo[i] = Math.min(
    i % 3 == 0 ? memo[i/3] + 1 : Integer.MAX_VALUE,
    Math.min(
        i % 2 == 0 ? memo[i/2] + 1 : Integer.MAX_VALUE,
        memo[i-1] + 1
    )
);
```

2. BufferedWriter 사용
   - 출력 성능 향상을 위해 BufferedWriter 적용 가능