# [균형잡힌 세상](https://www.acmicpc.net/problem/4949)

## 📌 문제
세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다.

정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다.

문자열에 포함되는 괄호는 소괄호("()") 와 대괄호("[]")로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.

- 모든 왼쪽 소괄호("(")는 오른쪽 소괄호(")")와만 짝을 이뤄야 한다.
- 모든 왼쪽 대괄호("[")는 오른쪽 대괄호("]")와만 짝을 이뤄야 한다.
- 모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다.
- 모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다.
- 짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다.

정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.

### 입력
각 문자열은 마지막 글자를 제외하고 영문 알파벳, 공백, 소괄호("( )"), 대괄호("[ ]")로 이루어져 있으며, 온점(".")으로 끝나고, 길이는 100글자보다 작거나 같다.

입력의 종료조건으로 맨 마지막에 온점 하나(".")가 들어온다.

### 출력
각 줄마다 해당 문자열이 균형을 이루고 있으면 "yes"를, 아니면 "no"를 출력한다.

### 예제 입력 1

     So when I die (the [first] I will see in (heaven) is a score list).
     [ first in ] ( first out ).
     Half Moon tonight (At least it is better than no Moon at all].
     A rope may form )( a trail in a maze.
     Help( I[m being held prisoner in a fortune cookie factory)].
     ([ (([( [ ] ) ( ) (( ))] )) ]).
      .
     .


### 예제 출력 1

     yes
     yes
     no
     no
     no
     yes
     yes

### 힌트
7번째의 " ."와 같이 괄호가 하나도 없는 경우도 균형잡힌 문자열로 간주할 수 있다.



### 🧰 풀이 과정

Stack을 이용한 괄호 균형 확인 구현
Stack을 선택한 이유:
- LIFO 특성이 괄호 매칭에 적합
- push, pop, peek 연산이 O(1)로 효율적


1. 입력 처리 및 주요 변수
   - while문 안에서 Stack과 boolean 변수들을 초기화
   - hasBracket: 괄호 존재 여부 체크
   - isValid: 현재 문자열의 유효성 상태 체크


2. 괄호 검사 로직
   - 여는 괄호는 stack에 push
   - 닫는 괄호는 stack의 pop과 매칭되는지 확인


3. 결과 출력
   - isValid로 우선 판단
   - 괄호가 없는 경우는 "yes"
   - stack이 비어있으면 "yes", 아니면 "no"



### 시간복잡도와 공간복잡도


    시간복잡도: O(N)
      - 각 문자열에 대해 한 번의 순회 O(N)
         - Stack 연산들(push, pop, peek)은 모두 O(1)
         - 문자열 길이를 L이라 할 때, 각 문자열 처리는 O(L)

    공간복잡도: O(N)
      - Stack: 최악의 경우 문자열 길이만큼 저장 O(N)
      - 결과 저장 ArrayList: 입력 줄 수만큼 저장 O(K), K는 입력 줄 수
      - 따라서 총 O(N)의 공간 필요



### ✨ 새롭게 배운 점
1. 변수 스코프와 초기화 위치의 중요성
   - Stack과 boolean 변수들을 while문 안에서 초기화해야 각 문자열마다 새로운 상태에서 시작 가능
   - while문 밖에서 초기화 시 이전 상태가 다음 문자열 검사에 영향을 줄 수 있음


2. 상태 관리 방식의 차이

   - 처음에 고수했던 잘못된 괄호를 stack에 넣고 마지막에 확인하는 방식
   - isValid 플래그로 즉시 유효성 체크하는 방식으로 바꿈
   - 두 방식 모두 논리적으로는 동일하나, 즉시 체크하는 방식이 더 명확하고 안전함 (모든 테스트 케이스 고려 못하겠으면 안전한 방식 선택하자)


3. 예외 처리
   - Stack이 비어있을 때 peek() 호출하면 예외 발생함
   - 예외 방지를 위해 isEmpty() 체크해줘야 함


### 💡 성능 개선 포인트
1. ArrayList 대신 StringBuilder 사용 가능
   - 문자열 결과 저장 및 출력할때 더 효율적


2. 잘못된 괄호 발견 즉시 처리
   - 불필요한 추가 검사 방지
   - 코드의 가독성과 유지보수성 향상

→ 상태 관리 방식이 코드의 안정성 & 가독성에 큰 영향을 미침