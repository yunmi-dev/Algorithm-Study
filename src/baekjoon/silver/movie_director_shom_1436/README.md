# [최대공약수와 최소공배수](https://www.acmicpc.net/problem/2609)

## 📌 문제
두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.

### 입력
첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.

### 출력
첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.

### 예제 입력 1

     24 18

### 예제 출력 1

     6
     72


### 🧰 풀이 과정

1. 기본 접근
   - 두 수 입력 후 큰 수와 작은 수 구분
   - 작은 수부터 1까지 내려가며 GCD 찾기
   - 작은 수의 배수를 늘려가며 LCM 찾기


2. 구현 상세
   - GCD(최대공약수): 작은 수부터 시작해 둘 다 나누어 떨어지는 첫 수
   - LCM(최소공배수): 작은 수의 배수 중 큰 수로 나누어 떨어지는 첫 수
   - Math.min, Math.max로 두 수의 대소 비교


### 시간복잡도와 공간복잡도

      
      시간복잡도: O(N)
         - GCD 계산: O(N), N은 작은 수의 크기
         - LCM 계산: O(N), N은 작은 수의 크기
         - 결국 O(N)이 됨
      
      공간복잡도: O(1)
         - 입력값 저장 변수들
         - 계산을 위한 임시 변수들
         - 추가 자료구조 사용하지 않음


### ✨ 새롭게 배운 점
1. break 활용
   - 조건 만족 시 반복문 즉시 종료
   - 불필요한 연산 방지


### 💡 성능 개선 포인트
1. 유클리드 호제법을 사용하면 시간복잡도가 O(log N)으로 개선됨
- 유클리드 호제법은 두 수의 최대공약수(GCD)를 구하는 알고리즘
- 원리
   - 두 양의 정수 a, b(a > b)에 대해서 a = bq + r (0 ≤ r < b)이라 하면,
   - a, b의 최대공약수는 b, r의 최대공약수와 같다
- 예시
   - GCD(24, 16)을 구할 때,
   - 24 = 16 × 1 + 8
   - 16 = 8 × 2 + 0
   - 따라서 GCD는 8이 된다
- 코드
```java
// 재귀 방식
int gcd(int a, int b) {
   if (b == 0) return a;
   return gcd(b, a % b);
}

// 반복문 방식
int gcd(int a, int b) {
   while (b != 0) {
      int r = a % b;
      a = b;
      b = r;
   }
   return a;
}
```
   
   * 현재 코드: O(N)
   
   ```java
   // GCD: smallNum부터 1까지 모든 수 체크
   for (int gcd = smallNum; gcd > 0; gcd--)  // O(N)
   
   // LCM: 배수를 하나씩 증가하며 체크
   while (true) {                            // O(N)
       int lcm = smallNum * i++;
   }
   ```
   
   * 유클리드 호제법 사용: O(log N)
   ```java
   // GCD 계산
   public static int gcd(int a, int b) {
      while(b != 0) {
         int r = a % b;
         a = b;
         b = r;
      }
      return a;
   }
   
   // LCM: GCD를 이용해 한번에 계산
   lcm = (a * b) / gcd;  // O(1)
   ```