# [평범한 배낭](https://www.acmicpc.net/problem/12865)

## 📌 문제
이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

### 입력
첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

### 출력
한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

### 예제 입력 1

     4 7
     6 13
     4 8
     3 6
     5 12

### 예제 출력 1

     14


### 🧰 풀이 과정

동적 계획법(DP)을 사용하여 해결

1. 상태 정의
   - dp[i][0]: i번째 잔을 마시지 않았을 때의 최대값
   - dp[i][1]: i번째 잔을 마시고, i-1번째 잔은 마시지 않았을 때의 최대값
   - dp[i][2]: i번째 잔과 i-1번째 잔을 연속으로 마셨을 때의 최대값


2. 초기값 설정
   - dp[1][0] = 0;
   - dp[1][1] = wines[1];
   - dp[2][0] = wines[1];
   - dp[2][1] = wines[2];
   - dp[2][2] = wines[1] + wines[2];


3. 점화식 도출
   - dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1][1], dp[i-1][2]));
   - dp[i][1] = Math.max(dp[i-2][0], Math.max(dp[i-2][1], dp[i-2][2])) + wines[i];
   - dp[i][2] = Math.max(dp[i-3][0], Math.max(dp[i-3][1], dp[i-3][2])) + wines[i-1] + wines[i];

* 처음에 시도했던 잘못된 점화식
   ```java
   dp[i][0] = dp[i-1][2];                  // 현재 잔을 안 마시는 경우: 한칸 전 상태들 중 최댓값
   dp[i][1] = dp[i-1][0] + wines[i];       // 현재 잔을 마시는 경우: 두칸 전 상태들 중 최대값 + 현재 와인잔
   dp[i][2] = dp[i-1][1] + wines[i];       // 현재 잔을 마시고, 이전 잔도 마신 경우: 세칸 전 상태들 중 최대값 + 직전 잔 + 현재 잔
   ```
  * 문제점:
    1) dp[i][0]: "이전 잔까지 연속 2잔을 마셨다면, 이번 잔은 마실 수 없으니 이전 상태를 그대로 가져오자" -> 그러나 이전 잔을 안 마셨다고 해서, 꼭 그 직전 상태(dp[i-1][0])에서만 와야 하는 건 아니다. 두 잔 전의 어떤 상태에서도 올 수 있다.
    2) dp[i][1]: "이전 잔을 안 마신 상태에서 현재 잔을 마시자" -> 그러나 이전 잔을 안 마셨다고 해서, 꼭 그 직전 상태(dp[i-1][0])에서만 와야 하는 건 아니다. 두 잔 전의 어떤 상태에서도 올 수 있다.
    3) dp[i][2]: "이전 잔을 마셨고, 그 이전 잔은 안 마신 상태에서 현재 잔을 마시자" -> 이전 잔을 마시더라도, 그 이전의 상태는 더 다양할 수 있다.


            * DP 문제 접근할 때 "바로 이전 상태"만 고려하려고 해서 발생한 실수인데, 더 이전 상태들도 함께 고려해야 최적해를 찾을 수 있다.


4. 최종 결과: n번째 위치에서의 세 가지 상태 중 최대값 선택



### 시간복잡도와 공간복잡도

      
      시간복잡도: O(N)
         - 각 i에 대해 상수 시간의 연산을 수행
         - i는 3부터 n까지 순회하므로 O(n)
      
      공간복잡도: O(N)
         - (n+1) × 3 크기의 2차원 배열(dp) 사용
         - n+1 크기의 1차원 배열(wines) 사용
         - 따라서 전체 공간복잡도는 O(n)



### ✨ 새롭게 배운 점
1. DP에서 상태 정의 하는법
   - 단순히 "이전에 마신 경우/안 마신 경우"가 아닌, 더 세분화된 상태 정의가 필요
   - 연속 3잔 제한을 효과적으로 처리하기 위한 상태 설계


2. DP 점화식 설계 방법
   - 현재 상태에 영향을 미치는 이전 상태들을 정확히 파악
   - 이전 2-3단계까지의 상태를 고려해야 하는 경우의 처리


3. 점화식 개선의 중요성
   - 처음 작성한 점화식의 한계를 파악하고 개선하는 과정에서 DP의 본질적인 특성을 더 깊이 이해
   - 각 상태에서 고려해야 할 이전 상태들의 범위를 정확히 파악하는 것의 중요성
   - 단순히 직전 상태만이 아닌, 더 이전 상태들도 고려해야 하는 경우가 있다는 것을 학습


4. 문제 제약 조건의 정확한 반영
   - "연속 3잔을 마실 수 없다"는 제약을 점화식에 정확히 반영하기 위해서는
   단순히 이전 상태만이 아닌, 2-3단계 이전의 상태까지 고려해야 함을 깨달음

### 💡 성능 개선 포인트
1. 메모리 사용 최적화

```java
// 현재: n+1 크기의 배열 사용
int[][] dp = new int[n + 1][3];

// 개선: 최근 3개 상태만 필요
int[][] dp = new int[4][3];
```
   - dp[i]의 계산에는 최대 3단계 이전의 상태만 필요
   - 순환 배열을 사용하여 공간복잡도를 O(1)로 개선 가능
