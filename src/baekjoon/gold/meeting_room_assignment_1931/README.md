# [회의실 배정](https://www.acmicpc.net/problem/1931)

## 📌 문제
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

### 입력
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

### 출력
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

### 예제 입력 1

     11
     1 4
     3 5
     0 6
     5 7
     3 8
     5 9
     6 10
     8 11
     8 12
     2 13
     12 14

### 예제 출력 1

     4

### 힌트
(1,4), (5,7), (8,11), (12,14) 를 이용할 수 있다.


### 🧰 풀이 과정
그리디 알고리즘을 사용하여 해결
- 종료 시간이 이른 순서대로 정렬하는 것이 핵심
- 종료 시간이 같은 경우 시작 시간이 이른 순서로 정렬

그리디 선택의 정당성:
- 종료 시간이 빠른 회의를 선택하면 남은 시간이 많아져 더 많은 회의 배정 가능
- 이른 종료 시간 선택이 항상 최적해를 보장함!

### 초기 접근 방법 (실패)
```java
Collections.sort(meetingList, (a, b) -> Integer.compare(a[0], b[0])); // 시작 시간으로만 정렬
int count = 1;
for (int i = 0; i < meetingList.size(); i++) {
    int endTime = meetingList.get(i)[1];
    if (meetingList.get(i)[0] >= endTime) {
        count++;
        endTime = meetingList.get(i)[1];
    }
}
```
- 정렬 기준이 잘못됨
  - 시작 시간만 정렬 기준
  - 이로 인해 긴 회의가 먼저 선택되어 더 많은 짧은 회의들을 놓침
- 논리적 오류
  - endTime 변수 업데이트가 안되고 있음
  - 회의 선택 조건이 부적절함


### 개선된 풀이
1. 입력 처리
   - BufferedReader를 사용하여 회의 수(N)와 회의 시간 입력
   - ArrayList<int[]>에 회의 시간 저장

2. 정렬
   - Collections.sort()를 사용하여 회의 종료 시간 기준 정렬
   - 종료 시간이 같은 경우 시작 시간으로 정렬

3. 회의실 배정
   - 이전 회의 종료 시간보다 시작 시간이 같거나 늦은 회의 선택
   - 선택된 회의의 종료 시간을 새로운 기준으로 설정


### 시간복잡도와 공간복잡도

      
      시간복잡도: O(N log N)
         - 입력 처리: O(N)
         - 정렬: O(N log N) (Collections.sort는 TimSort 알고리즘 사용)
         - 회의실 배정을 위한 순회: O(N)
         - 전체 시간복잡도는 가장 큰 차수인 O(N log N)이 됨 (주로 정렬 과정에서 발생함)
         - 주어진 제한 시간(2초)과 입력 크기 (N <= 100,000)를 고려할 때 충분히 효율적임
      
      공간복잡도: O(N)
         - ArrayList에 N개의 회의 정보(int[] 배열) 저장: O(N)
         - 정렬 시 임시 공간: O(N)
         - 기타 변수(count, lastEndTime): O(1)
         - 따라서 전체 공간복잡도는 O(N)



### ✨ 새롭게 배운 점
1. 그리디 알고리즘의 최적해 보장 조건
   - 이 문제에서는 종료 시간이 이른 순서대로 선택하는 것이 최적해를 보장
   - 종료 시간이 같은 경우 시작 시간도 고려해야 함


2. Comparator 람다식 활용
```java
Collections.sort(meetingList, (a, b) -> {
    if (a[1] == b[1]) return Integer.compare(a[0], b[0]);
    return Integer.compare(a[1], b[1]);
});
```

### 💡 성능 개선 포인트
1. 입출력 최적화
   - BufferedReader/BufferedWriter 사용으로 I/O 성능 향상
   - StringTokenizer 대신 split() 또는 문자열 파싱 최적화 가능


2. 자료구조 최적화
   - ArrayList 대신 배열 사용 가능
   - int[] 배열 대신 Meeting 클래스 정의하여 가독성 향상 가능
```java
class Meeting { 
    int start, end;
    Meeting(int start, int end) {
        this.start = start;
        this.end = end;
    }
}
```

3. 메모리 사용 최적화
   - 입력과 동시에 처리하여 메모리 사용 줄이기 가능
   - 불필요한 객체 생성 최소화